global.merge = function(o1, o2){
	if (!o1) o1 = {};
	var keys = Object.keys(o2 || {});
	
	for (var i = 0; i < keys.length; i++){
		o1[keys[i]] = o2[keys[i]];
	}
	return o1;
};

THREE.Vector2.prototype.mult = function(v){
	if (!v || typeof v != 'object') v = new THREE.Vector2(v,v);
	return new THREE.Vector2(this.x * v.x, this.y * v.y);
};
THREE.Vector2.prototype.toWorld = function(){
	let p = this.clone();
	p.x = 2 * p.x / global.innerWidth - 1;
	p.y = 1 - 2 * p.y / global.innerHeight;
	return p;
};

THREE.Vector3.prototype.mult = function(v){
	if (!v || typeof v != 'object') v = new THREE.Vector3(v,v,v);
	return new THREE.Vector3(this.x * v.x, this.y * v.y, this.z * v.z);
};
THREE.Vector3.prototype.toScreenPos = function(camera){
	let p = this.clone();
	p.project(camera);
	return new THREE.Vector2(
		(p.x + 1) * global.innerWidth / 2,
		(1 - p.y) * global.innerHeight / 2
	);
};

THREE.Raycaster.Intersection = {
	distance: 'Number',
	face: 'Object',
	faceIndex: 'Number',
	object: 'Shape',
	point: 'Vector3',
	uv: 'Vector2'
};

var updates = [];

exports.Start = function(scene, camera, renderer, objects){
	for (var name in objects){
		let o = objects[name];
		
		o.scene = scene;
		o.camera = camera;
		o.renderer = renderer;
		
		o.Start(objects);
		
		if (o.mesh){
			if (o.mesh instanceof Array){
				for (var i = 0; i < o.mesh.length; i++){
					scene.add(o.mesh[i]);
				}
			}
			else{
				scene.add(o.mesh);
			}
		}
		
		if (o.Update) updates.push(o.Update.bind(o));
	}
};

exports.Update = function(){
	for (var i = 0; i < updates.length; i++){
		updates[i]();
	}
};